# Dijkstra原理:
## 1.定義概覽
Dijkstra算法是典型的單源最短路徑算法，用於計算一個節點到其他所有節點的最短路徑。主要特點是以起始點為中心向外層層擴展，直到擴展到終點為止。 Dijkstra算法是很有代表性的最短路徑算法，在很多專業課程中都作為基本內容有詳細的介紹，如數據結構，圖論，運籌學等等。注意該算法要求圖中不存在負權邊。
問題描述：在無向圖 G=(V,E) 中，假設每條邊 E[i] 的長度為 w[i]，找到由頂點 V0 到其餘各點的最短路徑。 （單源最短路徑）

## 2.算法描述

1)算法思想：設G=(V,E)是一個帶權有向圖，把圖中頂點集合V分成兩組，第一組為已求出最短路徑的頂點集合（用S表示，初始時S中只有一個源點，以後每求得一條最短路徑, 就將加入到集合S中，直到全部頂點都加入到S中，算法就結束了），第二組為其餘未確定最短路徑的頂點集合（用U表示），按最短路徑長度的遞增次序依次把第二組的頂點加入S中。在加入的過程中，總保持從源點v到S中各頂點的最短路徑長度不大於從源點v到U中任何頂點的最短路徑長度。此外，每個頂點對應一個距離，S中的頂點的距離就是從v到此頂點的最短路徑長度，U中的頂點的距離，是從v到此頂點只包括S中的頂點為中間頂點的當前最短路徑長度

# Kruskal原理:
## 1.定義概覽
無向圖G=(V,E)的一個切割(S,VS)是集合V的一個劃分，如果一條邊(u,v)屬於E，並且一個端點位於集合S，另一個端點位於VS，則稱該條邊橫跨切割(S,VS)。如果集合A是邊的集合，不存在橫跨該切割的邊，則稱該切割尊重集合A。在橫跨一個切割的所有邊中，權重最小的變稱為輕量級邊。

## 2.算法描述
Kruskal算法是基於貪心的思想得到的。首先我們把所有的邊按照權值先從小到大排列，接著按照順序選取每條邊，如果這條邊的兩個端點不屬於同一集合，那麼就將它們合併，直到所有的點都屬於同一個集合為止。至於怎麼合併到一個集合，那麼這裡我們就可以用到一個工具——-並查集。換而言之，Kruskal算法就是基於並查集的貪心算法。



# 流程圖:
## Dijkstra:
![](/S__3957200.jpg)
## Kruskal:
![](/S__3957198.jpg)

# 學習歷程:
## 終於來到了這學期最後一次的作業了。經過了前面五次作業的洗禮，終於看透了人間百態。儘管一路上多麼的艱辛，我仍然與我身邊的朋友們一起攜手度過，記得剛開學時老師跟我們說，平常一起吃喝玩樂的朋友不是真朋友，只有一起寫程式的才是真朋友。但經過這學期後我發現，為什麼我們非得要兩者選一者呢?到了學期末，我平常身邊的朋友也沒有因為我不會寫程式而離開我，我反而交到了其他會寫程式的朋友，要是沒有這堂課，我應該永遠不會與他們成為朋友吧!所以其實人是可以同時可以擁有吃喝玩樂的朋友以及一起寫程式的朋友的。雖然我程式碼的部分沒有進步太多(還是有進步啦)，但我學到了許多以前沒學過的邏輯，其實也是蠻有趣的啦，也不會再像以前那樣抗拒學習了。
## 總之在做這次作業時，內心百感交集，想到這一路走來，內心有好多話想說。也有許多人想要感謝，一路上受到太多人的幫助了。得之於人者太多，出之於己者太少。因為需要感謝的人太多了，就感謝天吧!



# 參考資料:
## https://blog.csdn.net/yalishadaa/article/details/55827681
## https://blog.csdn.net/qq_23014515/article/details/51253949
## https://blog.csdn.net/luomingjun12315/article/details/47700237
## https://github.com/blakeli119/blakeli1109
